# 2019.3.07 企業実習

## Java オブジェクトとは
- 部品の汎用化　→　フレームワーク
	- 例えば通信のフレームワーク
		- プロトコルやリクエストのパラメータを入れておくなど
- オブジェクトとは実体 ⇒ 実際に言うとメモリを持つもの
- オブジェクトを使って作成したもの、作られたもを**インスタンス**と呼ぶ


#### サイコロオブジェクトのクラス

```java
package sample13_01;

public class Dice {
	int val;	//　フィールド変数(他の言語ではグローバル変数)
	public void play(){}　//このメソッドからグローバル変数を自由に呼び出せる

}
```

- これまで変数はメソッドの中で宣言していた。それはローカル変数という　　
なぜローカルかというと、メソッドが呼び出されて実行を開始した時に作成され、終了とともに消滅するから
- これに対してオブジェクトが持つ変数はフィールド変数という
- フィールド変数
	- メソッドの外で宣言する
	- 上記3行目のvalはオブジェクトが存在している間、ずっと存在する
	- そのためplayのようなクラス内にあるメソッドから自由にアクセスできる
	- 全部のメソッドから共有で使えるため代入される値が上書きされる可能性もある
	- メソッド内で宣言した変数はローカル変数となり、メソッド内でしか使用できない。
		- グローバル変数と同名の変数をメソッド内で宣言した場合、メソッド内のローカル変数が優先される
- オブジェクトには**static**を付けない
	- staticの付かないメソッドはインスタンスメソッドという



#### オブジェクトの作り方
- 上のDiceクラスを使ってオブジェクトを量産する方法
- **new**という演算子を使う
	- new class名　→　このクラス名の部分をコンストラクタという
- newで作成したここのオブジェクトをインスタンスという
	- インスタンスはクラスから作成されたもの
	- オブジェクトが「対象」という一般的な意味合いを持つ

```java
package sample13_01;

public class Exec {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Dice dice = new Dice();
		dice.val = 1;
		System.out.println("目数＝" + dice.val);

	}

}
```
- newはオブジェクトを作る演算子
- Dice dice = new Dice();の一番左は「Dice型」
	- クラスを作るとDice型を使ってよい、という決まりで覚える
	- 変数valには0が入る。入る値を定義していない場合、**オブジェクトの初期化の既定値**といって  
型によって決まっている既定値に自動的に初期化される
- **新しいクラスを作ること　＝　新しい型を作ること**
- クラスメソッドはインスタンス化できない(だからstaticがつく)。呼び出すだけ。
	- **オブジェクトにはstaticが付かない！！**
- フィールド変数は常にインスタンスが入っている変数名と共に使う　→　dice.val = 1;

#### メンバ参照演算子
- オブジェクトの構成要素であるフィールド変数とメソッドを併せて**メンバ**という。
- メンバ参照演算子は最も高い優先順位となるため、()で囲む必要なし
	- 例)　int val = dice.val * 3; ⇒ int val = (dice.val) * 3;　これは不要

#### メソッドまとめ
- オブジェクトのクラス作成↓

```java
package ex13_01;

public class Card {
	String suit;
	int number;

	public void disp(){
		System.out.println(suit);
		System.out.println(number);
	}

}

```

- インスタンスメソッドの実行

```java
package ex13_01;

public class Exec {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		Card card = new Card();
		card.suit = "スペード";
		card.number = 1;
		card.disp();

	}

}
```


### クラスのコンストラクタ
- `Dice dice = new Dice();` ⇒ これは何もしないコンストラクタ
	- 何もしないので`dice.val = 1;`のようにプログラムで初期値を設定しなくてはならない
	- このコンストラクタは自動で作られるので、デフォルトコンストラクタという
	- コンストラクタを定義するとデフォルトコンストラクタは使えなくなる

- コンストラクタの書き方
	- public クラス名(引数：複数可)
		- public ⇒　アクセス修飾子 public とすることが普通
	- フィールド変数に初期値をセットすることができる
	- newされた時にしかコンストラクタは使われない
- コンストラクタのオーバーロードは可能
	- オーバーロードとは、引数構成（引数の数、型、並び順）が違えば同名のメソッドが使える
	- つまりコンストラクタを定義してデフォルトコンストラクタ使えなくなる⇒使いたい場合は  
コンストラクタのない同名のクラスを定義すればよい

```java
package sample14_01;

public class Dice {
	int val;

	//コンストラクタ
	public Dice(int num){
		val = num;
	}

}

// 再度同名のクラスを定義してコンストラクタを記載しなければデフォルトコンストラクタを使える
public class Dice{
	int val;
}
```
#### thisの利用
- コンストラクタの引数にも推奨する書き方がある。それはコンストラクタの引数名とフィールド変数名を同じにすること
	- 以下のようにコンストラクタにval = val;　とエラーになる
	- そのため this を使う
		- this.val = val;  ⇒　thisは**「このオブジェクト」**という意味

```java
public class Dice {
	int val;

	//コンストラクタ
	public Dice(int num){
		val = val;　

	// いかに修正
	public Dice(int val){
	this.val = val;
	}

}
```

- class内のメソッドの書き方でpublic(アクセス修飾子)を省略して書ける↓
	- publicを省略すると意味が変わってくる
	- クラス内で()が付くのはコンストラクタのクラス名かメソッドとなる
		- そのためメソッドなら小文字始まり、コンストラクタならクラス名の大文字始まりとなる

```java
package ex14_01_1;

public class Card {
	String suit;
	int number;
	String face(){
		return suit + "/" + number;
	}
	public Card(String suit, int number){
		this.suit = suit;
		this.number = number;
	}
}
```
#### 整理
インスタンスメソッドかクラスメソッドを見分け方
- まず参照先をみる、そして
- インスタンスメソッド　→　インスタンス.メソッド
- クラスメソッド　→　staticである、クラス名.メソッド



#### メモリの使用や型について
javaのメモリ使用について
- スタック領域
	- 変数など基本データ型を格納する。作業領域
- ヒープ領域
	- 格納庫。配列やオブジェクトなど参照型を保存する。
- javaのjreがメモリを管理する

